<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>史蒂芬森的小屋</title>
  
  
  <link href="https://jiangyin0750.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiangyin0750.github.io/"/>
  <updated>2021-03-21T03:06:32.878Z</updated>
  <id>https://jiangyin0750.github.io/</id>
  
  <author>
    <name>史蒂芬森</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Opencv + C++学习笔记</title>
    <link href="https://jiangyin0750.github.io/post/%E5%9B%BE%E5%BD%A2/opencv/"/>
    <id>https://jiangyin0750.github.io/post/%E5%9B%BE%E5%BD%A2/opencv/</id>
    <published>2021-03-17T14:18:17.796Z</published>
    <updated>2021-03-21T03:06:32.878Z</updated>
    
    <content type="html"><![CDATA[<p>opencv使用的是BGR通道,转换时将RB位置对调即可<br><a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">RGB色表</a></p><h1 id="图像相关的API"><a href="#图像相关的API" class="headerlink" title="图像相关的API"></a>图像相关的API</h1><h2 id="imread-读取图片"><a href="#imread-读取图片" class="headerlink" title="imread - 读取图片"></a>imread - 读取图片</h2><p>函数原型:<code>Mat imread( const String&amp; filename, int flags = IMREAD_COLOR )</code><br>参数: </p><ul><li><code>const String&amp; filename</code>  读取图片的路径<br>  路径分为相对路径和绝对路径<br>  使用相对路径要保证图片在程序的源文件路径下，如果未包含在目录下的文件内直接写文件名,否则<code>&quot;文件名\\图像名&quot;</code><br>  绝对路径就是图像在计算机中的位置</li></ul><ul><li><code>int flags</code> 载入的方式<br>  <code>IMREAD_COLOR</code>为默认参数,意为使用BGR通道,<code>IMREAD_UNCHANGED</code>意为添加使用alpha通道<br>  更多的方式在定义在<code>ImreadModes</code>的枚举变量中,可通过再VS中按<code>CTRL</code>加左键点击<code>imread</code>再用同种方式点击<code>flags</code>查看</li></ul><p>返回值为<code>Mat</code>类型,因为需要用<code>Mat</code>类型来接受<br>示例:<code>Mat img = imread(&quot;image.jpg&quot;)</code></p><h2 id="namedWindow-新建windows窗口"><a href="#namedWindow-新建windows窗口" class="headerlink" title="namedWindow - 新建windows窗口"></a>namedWindow - 新建windows窗口</h2><p>函数原型:<code>void namedWindow(const String&amp; winname, int flags = WINDOW_AUTOSIZE)</code><br>参数: </p><ul><li><code>const String&amp; winname</code>  显示的window窗口名</li><li><code>int flags</code> 载入的方式<br>  可以使用默认参数,具体参数可在VS中<code>WindowFlags</code>中看,查找方式与上面的<code>ImreadModes</code>一样</li></ul><p>示例:<code>namedWindow(&quot;输出&quot;);</code></p><h2 id="imshow-输出图像"><a href="#imshow-输出图像" class="headerlink" title="imshow - 输出图像"></a>imshow - 输出图像</h2><p>函数原型:<code>void imshow(const String&amp; winname, InputArray mat)</code><br>参数:</p><ul><li><code>const String&amp; winname</code>  显示的window窗口名<br>  如果在输出前没有使用<code>namedWindow</code>新建窗口则自己新建新建,如果新建了可以输出到相应的窗口中</li></ul><ul><li><code>InputArray mat</code> 需要输出的图片</li></ul><p>示例:<code>imshow(&quot;输出窗口&quot;,image);</code></p><h2 id="waitKey-等待键盘输入"><a href="#waitKey-等待键盘输入" class="headerlink" title="waitKey - 等待键盘输入"></a>waitKey - 等待键盘输入</h2><p>函数原型:<code>int waitKey(int delay = 0);</code><br>参数:</p><ul><li><code>int delay</code> 等待时间<br>  如果参数不为<code>0</code>,则以毫秒(ms)为单位进行等待</li></ul><p>在显示完图片后需要在程序最后加上<code>waitKey(0);</code>,防止图片一闪而过看不见<br>此函数还可以获取键盘输入内容,使用方法<code>int key = waitKey();</code><br>返回值为<code>int</code>类型的,输入的键位与返回的大小与<code>ASCII码</code>对应</p><h2 id="cvtcolor-色彩空间转换"><a href="#cvtcolor-色彩空间转换" class="headerlink" title="cvtcolor - 色彩空间转换"></a>cvtcolor - 色彩空间转换</h2><p>函数原型:<code>void cvtColor( InputArray src, OutputArray dst, int code, int dstCn = 0 )</code><br>参数:</p><ul><li><code>InputArray src</code>  输入图像</li></ul><ul><li><code>OutputArray dst</code> 输出图像</li></ul><ul><li><code>int code</code>   要转换的色彩空间,具体参数参阅<code>ColorConversionCodes</code></li></ul><ul><li><code>int dstCn</code>  图片的通道数,0则为自动获取通道数</li></ul><p>示例: <code>cvtColor(img,dst,COLOR_BGR2GRAY);</code>  </p><h2 id="使用Mat创建空白图像"><a href="#使用Mat创建空白图像" class="headerlink" title="使用Mat创建空白图像"></a>使用Mat创建空白图像</h2><p>Mat绘制空白图像的API有很多,具体可以看Mat类的构造函数<br>函数原型:<code>zeros(int rows, int cols, int type)</code><br>参数:</p><ul><li><code>int rows</code>  宽度</li></ul><ul><li><code>int cols</code>  高度</li></ul><ul><li><code>int type</code>  类型<br>  这里的type需要是opencv中预定义的, 具体的格式在<code>interface.h</code>中<br>  构成有<code>CV_&lt;比特数&gt;(S|F|U)C&lt;通道数&gt;</code><br>  比特数看图片的像素大小进行选择<br>  <code>S</code>是有符号整型,<code>F</code>是单精度浮点型,<code>U</code>是无符号整型<br>  <code>&lt;通道数&gt;</code> 1为灰度图片,3为三通道图片,4为四通道图片</li></ul><p>示例:<code>Mat m = Mat::zeros(Size(600,800),CV_8UC3)</code>  <code>rows</code>和<code>cols</code>可以使用<code>Size</code>包含<br>     <code>zeros</code>可以改为<code>ones</code>这样得到的图片每个像素点的第一个通道值为1,<code>zeros</code>则为全0<br>使用<code>cout&lt;&lt;m&lt;&lt;endl;</code>可以得到图片的具体像素值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;opencv使用的是BGR通道,转换时将RB位置对调即可&lt;br&gt;&lt;a href=&quot;https://www.sioe.cn/yingyong/yanse-rgb-16/&quot;&gt;RGB色表&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;图像相关的API&quot;&gt;&lt;a href=&quot;#图像相关的API&quot; </summary>
      
    
    
    
    <category term="图形" scheme="https://jiangyin0750.github.io/categories/%E5%9B%BE%E5%BD%A2/"/>
    
    
    <category term="笔记" scheme="https://jiangyin0750.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Opencv" scheme="https://jiangyin0750.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>c++学习笔记</title>
    <link href="https://jiangyin0750.github.io/post/c/c++%20study/"/>
    <id>https://jiangyin0750.github.io/post/c/c++%20study/</id>
    <published>2020-08-25T02:41:12.459Z</published>
    <updated>2021-02-26T15:05:05.343Z</updated>
    
    <content type="html"><![CDATA[<p><font size="7" >以下代码基于VS2017运行实现</font> </p><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>函数默认的参数，调用函数可以不传参，如果传入参数则覆盖默认值</strong><br>书写规则: 从右到左进行判断，如果右边的参数没有默认值，则左边的参数无法拥有默认值<br>定义函数时可以不定义参数名，写函数体时也可以不定义，但是无法使用默认值<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a,int &#x3D; 3,int &#x3D; 10) &#x2F;&#x2F;定义函数</span><br><span class="line">void chat(int a,int b,int c) &#x2F;&#x2F;写函数体时，可以使用上面的格式，但是使用了就无法当参数进行使用</span><br></pre></td></tr></table></figure><p>定义示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void chat1 (int &#x3D; 2,int &#x3D; 10,int &#x3D; 20) &#x2F;&#x2F;不报错</span><br><span class="line">void chat1 (int ,int &#x3D; 10,int c) &#x2F;&#x2F;不报错</span><br><span class="line">void chat1 (int &#x3D; 2,int &#x3D; 10,int c) &#x2F;&#x2F;报错</span><br><span class="line">void chat1 (int &#x3D; 2,int b,int &#x3D; 20) &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure><hr><h1 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h1><p><strong>函数名一致，参数不同</strong><br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a, int b, int c);</span><br><span class="line">void chat(string b, string c);</span><br></pre></td></tr></table></figure><p>如果函数的参数不一样，但是传入的参数类型一致也会报错<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a, int &#x3D; 3, int &#x3D; 10); &#x2F;&#x2F;后两个默认参数，无需传入</span><br><span class="line">void chat(int b, string &#x3D; &quot;345&quot;);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    chat(1);     &#x2F;&#x2F;报错E0308 ,多个重载函数chat实例与参数列表匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注-同一类型的加-amp-与不加-amp-编译器无法识别"><a href="#注-同一类型的加-amp-与不加-amp-编译器无法识别" class="headerlink" title="注:同一类型的加&amp;与不加&amp;编译器无法识别"></a><strong>注:同一类型的加&amp;与不加&amp;编译器无法识别</strong></h2><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p><strong>可以自己判别数据的类型，不需要把相同的内容的函数，因为传入类型的不同而写很多个函数体</strong><br>函数模板定义形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename 类型参数1，typename 类型参数2&gt;  &#x2F;&#x2F;typename可以改为class</span><br><span class="line">返回值类型 函数名()&#123;</span><br><span class="line">  &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用函数模板写一个交换函数为例，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;  void Sort(T &amp;a, T &amp;b);</span><br><span class="line">int main() &#123;</span><br><span class="line">double a, b;</span><br><span class="line">cout &lt;&lt; &quot;输入内容&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; &quot;输入内容&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">Sort(a,b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; </span><br><span class="line">void Sort(T &amp;a, T &amp;b) &#123;</span><br><span class="line">T temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把double类型换为int，string，float，最终换位都会成功<br><strong>显式具体化</strong><br>可以判断传参的类型并且为这个类型的参数写的一个独立定义<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;  void Sort(T &amp;a, T &amp;b);</span><br><span class="line">struct abc &#123;     &#x2F;&#x2F;定义一个名为abc的结构体</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt; void Sort&lt;abc&gt;(abc &amp;a, abc &amp;b);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">abc a&#123; 10,20 &#125;, b&#123;20,10&#125;;</span><br><span class="line">Sort(a,b);  &#x2F;&#x2F;传abc类型的数据</span><br><span class="line">int c, d;</span><br><span class="line">c &#x3D; 1;</span><br><span class="line">d &#x3D; 5;</span><br><span class="line">Sort(c,d);  &#x2F;&#x2F;传int类型的数据</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; </span><br><span class="line">void Sort(T &amp;a, T &amp;b) &#123;</span><br><span class="line">T temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt; void Sort&lt;abc&gt; (abc &amp;a,abc &amp;b) &#123;   &#x2F;&#x2F;如果遇到参数abc类型此函数优先</span><br><span class="line">cout &lt;&lt; &quot;12345&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;template&lt;&gt; void Sort&lt;abc&gt; (abc &amp;a,abc &amp;b)也可以写为template&lt;&gt; void Sort (abc &amp;a,abc &amp;b)</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>注意: 类型参数的动态将在参数传入时变为对应的类型，如T被传入参数是1，则T是int的，而int不应存储姓名等string类型</p><hr><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p><strong>五种变量储存方式</strong></p><table><thead><tr><th>存储描述</th><th align="center">持续性</th><th align="right">作用域</th><th align="right">链接性</th><th align="right">声明</th></tr></thead><tbody><tr><td>自动</td><td align="center">自动</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中</td></tr><tr><td>寄存器</td><td align="center">自动</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中，使用关键字register</td></tr><tr><td>静态，无链接性</td><td align="center">静态</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中，使用关键字static</td></tr><tr><td>静态，外部链接性</td><td align="center">自动</td><td align="right">文件</td><td align="right">外部</td><td align="right">不在任何函数内</td></tr><tr><td>静态，内部链接性</td><td align="center">自动</td><td align="right">文件</td><td align="right">内部</td><td align="right">不在任何函数内，使用关键字static</td></tr></tbody></table><hr><h2 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h2><p>c++提供了两种变量声明，一是定义声明，他给变量分配内存；另一种是引用声明，他不给变量分配内存，因为他引用已有变量<br>引用声明使用关键字<code>extren</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; file1.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">extern int a; &#x2F;&#x2F;引用file2中名为a 的变量</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; file2.cpp</span><br><span class="line">int a &#x3D; 10;</span><br></pre></td></tr></table></figure><h2 id="控制台输出为10"><a href="#控制台输出为10" class="headerlink" title="控制台输出为10"></a>控制台输出为10</h2><h2 id="栈区与堆区"><a href="#栈区与堆区" class="headerlink" title="栈区与堆区"></a>栈区与堆区</h2><p>栈区:由系统进行内存的管理。<br>堆区:由程序员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。<br>堆区申请可用new关键字<br>对比示例：<br><strong>1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">int a &#x3D; 10;  &#x2F;&#x2F;栈区的变量</span><br><span class="line">return &amp;a; &#x2F;&#x2F;返回一个即将被释放内存的地址</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; func();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;在vs2017中输出为10 ，因编译器而异</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;输出为非10的数</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">int *a &#x3D; new int(10);  &#x2F;&#x2F;new一个堆区的变量</span><br><span class="line">&#x2F;&#x2F;new返回的是一个指针类型，所以要用*来接收</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; func();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;三次输出都为10</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;delete(p);   释放p的内存，运行会出错，前两行依旧可以输出</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>通过定义一种新的声明区域来创建命名的名称空间，为了让一个名称空间中的名称不会与另一个名称空间里的相同名发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西<br>关键词: <code>namespace </code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;file.h</span><br><span class="line">namespace Myfspace    &#x2F;&#x2F;定义一个名为Myfspace的名称空间</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;输出&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Mysspace</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域解析运算符"><a href="#作用域解析运算符" class="headerlink" title="作用域解析运算符::"></a>作用域解析运算符::</h2><p>示例：</p><ul><li>Myfspace::c;</li></ul><ul><li>Mysspace::c;</li></ul><ul><li>Myfspace::swap();</li></ul><hr><h2 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h2><p>using声明是特定的标识符可用，using编译指令是整个名称空间可用<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;上面file.h也算这堆代码内</span><br><span class="line">&#x2F;&#x2F;file1.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;file.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace Myfspace;  &#x2F;&#x2F;using编译指令</span><br><span class="line">using namespace Mysspace;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;using Myfspace::c;  &#x2F;&#x2F;using声明，只可使用c</span><br><span class="line">int a, b;</span><br><span class="line">a &#x3D; 10;</span><br><span class="line">b &#x3D; 20;</span><br><span class="line">c &#x3D; 11.11;&#x2F;&#x2F;报错c不明确,解决方法：改为Myfspace::c; 或 Mysspace::c;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">swap(a, b);  &#x2F;&#x2F;调用Myfspace中的swap函数</span><br><span class="line">Mysspace::print();&#x2F;&#x2F;调用Mysspace中print函数   Mysspace::可加可不加</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot;     &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="名称空间嵌套"><a href="#名称空间嵌套" class="headerlink" title="名称空间嵌套"></a>名称空间嵌套</h2><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace Myfspace</span><br><span class="line">&#123;</span><br><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">namespace Mysspace</span><br><span class="line">&#123;</span><br><span class="line">void printout()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;这里是Mysspace空间&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的Mysspace用using编译指令可表示为:</p><ul><li>using namespace Mysspace;</li></ul><ul><li>using namespace Myfspace::Mysspace;</li></ul><p><strong>名称空间的别名</strong><br>可用来简化嵌套的名称空间<br>语法: namespace &lt;别名&gt; = &lt;原名&gt;;<br>示例: <code>namespace T_space = Mysspace;</code></p><p><strong>无名的名称空间</strong><br>可以当作链接性为内部的静态变量<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">namespace     &#x2F;&#x2F;本名称空间无法在这个文件以外使用</span><br><span class="line">&#123;</span><br><span class="line">int c &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类是面向对象设计实现信息封装的基础，类的实例称为对象<br>类三大特性：</p><ul><li>封装性: 将私有成员进行隐藏，外部通过接口对成员进行修改</li></ul><ul><li>继承性: 节省重复代码</li></ul><ul><li>多态性: 同一操作对不同的类对象的结果不同</li></ul><h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:       &#x2F;&#x2F;公开权限，类内外皆可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">private:      &#x2F;&#x2F;私有权限，类内可访问，类外不可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">protected:    &#x2F;&#x2F;保护权限，类内可访问，类外不可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">&#x2F;&#x2F;file.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int name;  &#x2F;&#x2F;权限外的变量默认为私有，类外无法访问</span><br><span class="line">public:       &#x2F;&#x2F;公开权限，类内外皆可访问</span><br><span class="line">int pu_ages;</span><br><span class="line">void hpp();</span><br><span class="line">void showifmt()      </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pu_ages;</span><br><span class="line">&#125;</span><br><span class="line">private:      &#x2F;&#x2F;私有权限，类内可访问，类外不可访问</span><br><span class="line">int pri_ages;</span><br><span class="line">void showpri()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pri_ages;</span><br><span class="line">&#125;</span><br><span class="line">protected:    &#x2F;&#x2F;保护权限，类内可访问，类外不可访问</span><br><span class="line">int pro_ages;</span><br><span class="line">void showpro()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pro_ages;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person P1;</span><br><span class="line">cin &gt;&gt; P1.pu_ages;  &#x2F;&#x2F;写入P1的pu_ages属性值;</span><br><span class="line">P1.showifmt(); &#x2F;&#x2F;调用P1的方法showinmt</span><br><span class="line">&#x2F;&#x2F;P1.pro_ages;  &#x2F;&#x2F;错误E0265,成员所声明行不可访问</span><br><span class="line">&#x2F;&#x2F;P1.pri_ages;  &#x2F;&#x2F;错误如上</span><br><span class="line">&#x2F;&#x2F;P1.showpro(); &#x2F;&#x2F;错误如上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装特性体现:<br>public一般用来写方法，当作接口使用，可以用来对私有的数据进行修改;<br>private一般用来存数据，防止数据被修改</p><p><strong>struct和class的区别</strong><br>struct的默认权限是<code>public</code>的,class默认权限<code>private</code>的，其他大致一致</p><p><strong>实现类成员函数</strong></p><ul><li>定义成员函数时，使用作用域运算符<code>::</code>来标识函数所属的类</li></ul><ul><li>类方法可以访问类的private组件</li></ul><p><code>void person::hpp()</code>可在类外写函数主体，在类内需要声明，无论类内是什么作用域下都可以在类外写主体</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>构造函数分类：</p><ul><li>无参构造函数(默认不书写构造函数自动生成空函数)</li></ul><ul><li>有参构造函数：1.普通有参构造函数  2.拷贝构造函数</li></ul><hr><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设有一个person类</span><br><span class="line"></span><br><span class="line">person()   &#x2F;&#x2F;无参构造函数  未书写构造函数时默认生成空此函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(int value)  &#x2F;&#x2F;普通有参构造函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(const person&amp; p)  &#x2F;&#x2F;有参拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数被调用时机</p><ul><li>person P1      //无参构</li></ul><ul><li>person P2(10)  //有参构</li></ul><ul><li>person P3(p1)  //拷贝构</li></ul><p>假设以上代码可运行，则结果为依次输出1 2 3</p><p>调用构造函数风格:<br>以下代码基于person.cpp中，且两种等价</p><ul><li>显示地调用构造函数<code>person P1 = person(&quot;Myname&quot;)</code></li></ul><ul><li>隐式<code>person P1(&quot;Myname&quot;)</code>     </li></ul><p><strong>成员初始化列表</strong></p><p>可以将类中的非静态const变量赋初值<br>语法:<code>&lt;类名&gt;(传入参数):类成员(传入参数)</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int a,int b):age(a),len(b),c(a)&#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int age;</span><br><span class="line">const int len;</span><br><span class="line">int &amp;c;   &#x2F;&#x2F;引用数据类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝与浅拷贝</strong></p><p>浅拷贝:直接复制拷贝内容<br>深拷贝:在堆区重新申请一块内存进行赋值操作<br>如果使用浅拷贝在堆区开内存会可能导致内存重复释放的问题<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">person.cpp</span><br><span class="line">&#x2F;&#x2F;浅拷贝</span><br><span class="line">&#x2F;&#x2F;使用默认的拷贝构造函数，简单的将新的对象与传入的对象进行赋值</span><br><span class="line">&#x2F;&#x2F;class person</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;public:</span><br><span class="line">&#x2F;&#x2F;person(int a)</span><br><span class="line">&#x2F;&#x2F;&#123; </span><br><span class="line">&#x2F;&#x2F;age &#x3D; new int(a);</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;~person()</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;delete age;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#x2F;&#x2F;int *age;</span><br><span class="line">&#x2F;&#x2F;&#125;;</span><br><span class="line">&#x2F;&#x2F;深拷贝</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int a)</span><br><span class="line">&#123; </span><br><span class="line">age &#x3D; new int(a);</span><br><span class="line">&#125;</span><br><span class="line">person(const person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line">age &#x3D; new int(*p.age);  &#x2F;&#x2F;在堆区内为新的对象开一块内存，浅拷贝将指向p.age的内存地址</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">delete age;</span><br><span class="line">age &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">int *age;</span><br><span class="line">&#x2F;&#x2F;file.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person s1(10);</span><br><span class="line">person s2(s1);</span><br><span class="line">cout &lt;&lt; *s1.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *s2.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出为:<br>\10<br>\10<br>000001FDA63666C0<br>000001FDA636A9C0<br>值相等地址不同，不会出现内存重复释放<br>如是浅拷贝则会有两个指向原为p.age的内存地址，释放时会两次释放，第一次释放程序不会崩溃，第二次释放会崩</p><p><strong>初始化工作是在对象创建时完成的，此时还未执行括号里的任何代码</strong></p><p>成员初始化列表注意:</p><ul><li>这种格式只能用于构造函数</li></ul><ul><li>必须用这种格式来初始化非静态const变量</li></ul><ul><li>必须用这种格式来初始化引用数据类型</li></ul><p>注意事项:<br>1.不要把类成员名当作构造函数的的参数名，会引起混乱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">person.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name)</span><br><span class="line">&#123;</span><br><span class="line">name &#x3D; name        &#x2F;&#x2F;可以用加入前缀或后缀。this指针也可以解决问题</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;123&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果未给类提供构造函数，则编译器会生成默认构造函数，但如果写了构造函数，则必须提供无参构造函数，不然会报错</p><hr><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象过期时，程序会自动调用析构函数，析构函数用来完成清理工作。<br>特点：析构函数没有参数，返回值和声明类型<br>语法<code>~&lt;类名&gt;</code>，如<code>~person</code></p><p>析构函数被调用时机</p><ul><li>对象过期时</li></ul><ul><li>delele时(仅限于new出来的对象)</li></ul><p>如person.cpp中的代码将会在程序结束时输出123</p><p>与构造函数一样，如果类中没有书写构造函数，编译器也会生成默认析构函数</p><p><strong>C++11 列表初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person::person(const std::string &amp; co, long n &#x3D; 0, double pr &#x3D; 0;)</span><br><span class="line">person P1 &#x3D; &#123; &quot;Smicth&quot; &#125;;    &#x2F;&#x2F;P1默认参数0，0</span><br><span class="line">person P2 &#x3D; &#123; &quot;Mark&quot;,100,10.5 &#125;;    &#x2F;&#x2F;P2不使用默认参数</span><br><span class="line"> 和括号传参结果无区别</span><br></pre></td></tr></table></figure><p><strong>const成员函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stock()</span><br><span class="line">&#123;</span><br><span class="line">int ages;</span><br><span class="line">public:</span><br><span class="line">Stock(int temp)</span><br><span class="line">&#123;</span><br><span class="line">ages &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void show() &#x2F;&#x2F;const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ages &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const P1(10);</span><br><span class="line">P1.show();&#x2F;&#x2F;错误E1086   因为编译器无法确保调用对象不被修改  只需在函数后面加一个const</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每一个对象都能通过this指针来访问自己的地址。this指针是所有成员函数的隐含参数。<br>因此在成员函数内部,它可以用来指向调用对象</p><p>如上面的person.cpp的构造函数因为名称冲突而造成了混论，无法赋初值，而this指针则可以解决这个问题</p><h3 id="this实现链式编程"><a href="#this实现链式编程" class="headerlink" title="this实现链式编程"></a>this实现链式编程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int abc;</span><br><span class="line">public:</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">abc &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">person &amp;Add()</span><br><span class="line">&#123;</span><br><span class="line">abc +&#x3D; 10;</span><br><span class="line">return *this;    &#x2F;&#x2F;用*运算符将p1以p1文字形式返回回去</span><br><span class="line">&#125;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; abc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">p1.Add().Add();     &#x2F;&#x2F; 连续调用两次Add函数，第一次调用返回回来一个p1，从而实现再次调用</span><br><span class="line">p1.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为30</span><br></pre></td></tr></table></figure><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>定义语法:<code>&lt;类名&gt; &lt;变量名&gt;[元素数]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</code><br>如：<br>假设有一有参构造函数,有一个ages属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person value[3]&#123;</span><br><span class="line">&#123;2&#125;,    &#x2F;&#x2F;ages属性赋值，下同</span><br><span class="line">&#123;2&#125;,</span><br><span class="line">&#123;1&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cout&lt;&lt;value[0].ages;</span><br></pre></td></tr></table></figure><h3 id="静态成员变量和函数"><a href="#静态成员变量和函数" class="headerlink" title="静态成员变量和函数"></a>静态成员变量和函数</h3><p>对象成员函数是每个对象独立的内存，而静态成员函数则是共享一段内存<br>静态成员变量特点：</p><ul><li>类内声明，类外初始化</li></ul><ul><li>所有对象共享同一份数据</li></ul><ul><li>在编译阶段分配内存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;static.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int M_B &#x3D; 10;</span><br><span class="line">static int M_A;    &#x2F;&#x2F;注意:类内禁止赋值</span><br><span class="line">static void func();</span><br><span class="line">&#125;</span><br><span class="line">int person::M_A &#x3D; 10；     &#x2F;&#x2F;类外初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person P1;</span><br><span class="line">person P2;</span><br><span class="line">cout &lt;&lt; P1.M_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; P2.M_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">输出结果均为10</span><br></pre></td></tr></table></figure><p><strong>静态成员函数</strong></p><ul><li>程序共享一个函数</li></ul><ul><li>静态成员函数只能访问静态成员变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static01.cpp</span><br><span class="line">void person::func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; M_A &lt;&lt; endl;&#x2F;&#x2F;静态成员变量可被访问</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; M_B &lt;&lt; endl;     &#x2F;&#x2F;非静态成员变量无法被访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h1><p>重载运算符可以实现自以定类型的四则运算以及类似int类型的比大小功能<br>重载运算符是c++形式的一种多态<br>c++中可重载运算符</p><table><thead><tr><th>运算符类型</th><th align="center">可重载</th></tr></thead><tbody><tr><td>双目算术运算符</td><td align="center">+ ，-，*，/，%</td></tr><tr><td>关系运算符</td><td align="center">==，!= ，&lt; ，&gt; ，&lt;=，&gt;=</td></tr><tr><td>逻辑运算符</td><td align="center">||，&amp;&amp;，!</td></tr><tr><td>单目运算符</td><td align="center">+ ，-，*，&amp;</td></tr><tr><td>自增自减运算符</td><td align="center">++，–</td></tr><tr><td>位运算符</td><td align="center">&amp;，~，^,，&lt;&lt; ，&gt;&gt;，|</td></tr><tr><td>赋值运算符</td><td align="center">=, +=, -=, *=, /= , % = , &amp;=,</td></tr><tr><td>空间申请与释放</td><td align="center">new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td align="center">()，-&gt;，,，[]</td></tr></tbody></table><p>语法：<code>&lt;返回值类型&gt;operator&lt;运算符&gt;(参数)</code></p><h2 id="实现自以定的类型相加并输出示例："><a href="#实现自以定的类型相加并输出示例：" class="headerlink" title="实现自以定的类型相加并输出示例："></a>实现自以定的类型相加并输出示例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;text.h</span><br><span class="line">class text</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">text operator+(text &amp;a)   </span><br><span class="line">&#123;</span><br><span class="line">text temp;   &#x2F;&#x2F;创建一个临时变量</span><br><span class="line">temp.M_A &#x3D; M_A + a.M_A;</span><br><span class="line">temp.M_B &#x3D; M_B + a.M_B;</span><br><span class="line">return temp;  &#x2F;&#x2F;返回临时变量</span><br><span class="line">&#125;</span><br><span class="line">text()&#123;&#125;</span><br><span class="line">void operator&lt;&lt;(ostream &amp;os)  &#x2F;&#x2F;重载&lt;&lt;运算符，ostream是标准输出流</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; &quot;M_A:&quot; &lt;&lt; M_A &lt;&lt; &quot;   &quot; &lt;&lt; &quot;M_B:&quot; &lt;&lt; M_B;</span><br><span class="line">&#125;</span><br><span class="line">text(int a, int b)  &#x2F;&#x2F;有参构造</span><br><span class="line">&#123;</span><br><span class="line">M_A &#x3D; a;</span><br><span class="line">M_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int M_A;</span><br><span class="line">int M_B;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;main.cpp</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text a(10,10);</span><br><span class="line">text b(10,10);</span><br><span class="line">text c;</span><br><span class="line">c &#x3D; a + b;   &#x2F;&#x2F;与c &#x3D; a.operator+(b);同义</span><br><span class="line">c &lt;&lt; cout;   &#x2F;&#x2F;与c.operator&lt;&lt;(cout);同义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c&lt;&lt;cout</code>；是在类内重载&lt;&lt;运算符的，本质是调用函数，与<code>cout&lt;&lt;c</code>相比看起来有一点怪<br>可以用全局重载&lt;&lt;解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在main.cpp加入</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;cout,text &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;M_A:&quot; &lt;&lt; p.M_A &lt;&lt; &quot;M_B:&quot; &lt;&lt; p.M_B;</span><br><span class="line">return cout;   &#x2F;&#x2F;把cout当作返回值返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在class类中声明此函数为友元函数即添加一行<code>friend ostream &amp; operator&lt;&lt;(ostream &amp;cout, text &amp;p);</code><br>此版本可实现类似<code>cout&lt;&lt;c&lt;&lt;endl;</code>的实现<br>在全局重载&lt;&lt;,<code>cout&lt;&lt;c;</code>与<code>operator&lt;&lt;(cout,c);</code>同义<br>返回cout的意义是让<code>cout&lt;&lt;c</code>变为返回的cout从而继续实现下一步</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>将自以定的类型赋值给标准类型如<code>double a = p1;</code>(假设p1是一个类对象)<br>也可以将自以定类型赋值给自以定类型如<code>text a = p1;</code>(假设a和p1非同一类的对象)<br>可以通过重载<code>=</code>运算符实现相同效果<br>语法:<code>operator &lt;转换目标类型&gt;()</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">person1.h</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int a):age(a)&#123;&#125;;</span><br><span class="line">operator double()&#123;return age;&#125;;</span><br><span class="line">private:</span><br><span class="line">double age;</span><br><span class="line">&#125;;</span><br><span class="line">file.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">double a &#x3D; p1;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:10</span><br></pre></td></tr></table></figure><hr><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>友元有三种:</p><ul><li>友元函数</li></ul><ul><li>友元类</li></ul><ul><li>友元成员函数</li></ul><hr><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。<br>只需在函数原型写入类声明中并在最前面加入<code>friend</code>，该函数就是该类的友元函数<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">friend.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">friend void show(person &amp;p);  &#x2F;&#x2F;友元函数不是类的成员，所以不需要在意是否是public作用域</span><br><span class="line">int age;</span><br><span class="line">&#125;</span><br><span class="line">void show(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中声明为友元函数后，便可以访问类中private作用域下的成员。</p><hr><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>待补~</p><hr><h2 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h2><p>待补~</p><hr><h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>类继承优点</p><ul><li>当代码产生重复时可以使用继承来减少代码量,</li></ul><ul><li>可以在类的基础上添加成员,</li></ul><ul><li>可以重写基类成员函数</li></ul><p>类继承可以分为三种继承方法</p><ul><li>公有继承(public)</li></ul><ul><li>保护继承(private)</li></ul><ul><li>私有继承(protected)</li></ul><p>类与类的关系有<code>is-a</code>和<code>has-a</code>,关系并不止这两种<br>is-a是一种的父子继承关系,has-a是一种包含关系<br>示例</p><ul><li>is-a: class A{};    class B: A{};  </li></ul><ul><li>has-a: class C{A a;};<br>被派生类称为基类,从基类派生下来的类被称为派生类</li></ul><h2 id="类继承语法"><a href="#类继承语法" class="headerlink" title="类继承语法"></a>类继承语法</h2><p>继承的基本语法<code>class &lt;派生类名&gt; : &lt;继承方式&gt;&lt;基类名&gt;</code><br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;;</span><br><span class="line">class B : public A &#123;&#125;;     &#x2F;&#x2F;B公有继承A</span><br><span class="line">class C : protected A &#123;&#125;;  &#x2F;&#x2F;C保护继承A</span><br><span class="line">Class D : A&#123;&#125;;             &#x2F;&#x2F;D私有继承A,如类的成员声明一样,如果不明示继承的方式将会认定为私有继承</span><br></pre></td></tr></table></figure><p><strong>三种继承特点</strong></p><table><thead><tr><th>特征</th><th align="center">公有继承</th><th align="right">保护继承</th><th align="right">私有继承</th></tr></thead><tbody><tr><td>公有成员变成</td><td align="center">派生类的公有成员</td><td align="right">派生类的保护成员</td><td align="right">派生类的私有成员</td></tr><tr><td>保护成员变成</td><td align="center">派生类的保护成员</td><td align="right">派生类的保护成员</td><td align="right">派生类的私有成员</td></tr><tr><td>私有成员变成</td><td align="center">只能通过基类接口访问</td><td align="right">只能通过基类接口访问</td><td align="right">只能通过基类接口访问</td></tr><tr><td>能否向上隐式转换</td><td align="center">能</td><td align="right">能(只能在派生类中)</td><td align="right">否</td></tr></tbody></table><p>基类的构造函数可以使用成员初始化列表调用基类的构造函数<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;jicheng.h</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A(int a, int b) : m_a(a), m_b(b) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int m_a;</span><br><span class="line">int m_b;</span><br><span class="line">&#125;;</span><br><span class="line">class B :public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">B(int a, int b, int c) :A(a, b), m_c(c) &#123;&#125;; </span><br><span class="line">private:</span><br><span class="line">int m_c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类对象的指针和引用是可以指向派生类对象的,这是单向特性,派生类不能指向基类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本代码基于jicheng.h</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A *a;</span><br><span class="line">B b(1,2,4);</span><br><span class="line">a &#x3D; &amp;b;       &#x2F;&#x2F;A类型的指针等于b</span><br><span class="line">A &amp;a1 &#x3D; b;    &#x2F;&#x2F;A类型的引用指向b</span><br><span class="line">&#x2F;&#x2F;B &amp;b1 &#x3D; a;  &#x2F;&#x2F;会报错</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>多重继承会带来的问题使用虚继承来解决<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;virtext.h</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func() &#123;&#125;;</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A&#123;&#125;;</span><br><span class="line">class C : public A&#123;&#125;;</span><br><span class="line">class D : public C ,public B&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;file.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">D d;  </span><br><span class="line">&#x2F;&#x2F;d.func();    &#x2F;&#x2F;如果不注释,错误E0266: func不明确             相应行输出</span><br><span class="line">cout &lt;&lt;&quot;D sizeof:&quot;&lt;&lt; sizeof(D) &lt;&lt; endl;                          8</span><br><span class="line">cout &lt;&lt; &quot;B sizeof:&quot; &lt;&lt; sizeof(B) &lt;&lt; endl;                        4</span><br><span class="line">cout &lt;&lt; &quot;C sizeof:&quot; &lt;&lt; sizeof(C) &lt;&lt; endl;                        4</span><br><span class="line">cout &lt;&lt; &quot;A sizeof:&quot; &lt;&lt; sizeof(A) &lt;&lt; endl;                        4  </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误的原因时因为B,C两个类都个子继承一个A类,所以D类继承到了2个A类，因此出现了不明确<br>根据类字节大小的辅助判断,D类的理想大小应为4byte,但结果为8byte,由此可以看出有两个int类型的数据存在于D类中<br>抽象为图形来看就是  |B(A)|  |C(A)|  |D(B,C)|<br>解决方法就是将8,9行的<code>public</code>前加<code>virtual</code>关键字<br>加上<code>virtual</code>后这就是虚继承,称为虚继承后在B,C类中包含了一个指向A的虚基类指针列表vbptr(virtual(虚) base(基类) ptr(指针)),其中记录的是B,C的首地址到A元素之间的偏移量<br>一般来说基类的析构函数的要定义为虚函数</p><hr><h2 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h2><p>联编: 将源代码中的函数调用解释为执行待定的函数代码块被称为函数名联编<br>在编译过程中进行的联编被称为静态联编,因为其效率高因此被定为C++默认联编方式<br>编译器必须生成能够在程序运行时选择正确的虚方法的代码被称为动态联编<br>实现动态联编在类的函数声明前加入<code>virtual</code>即可<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;vir.h</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;12&quot; &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func()   &#x2F;&#x2F;重写函数也是虚函数，不用加virtual，加了也一样</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;34&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;main.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">B b;</span><br><span class="line">A *a &#x3D; &amp;b;</span><br><span class="line">a-&gt;func();    &#x2F;&#x2F;输出34，如果不是虚函数则输出为12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚函数其工作原理与虚函数表和虚表指针有关</p><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="排序函数-sort"><a href="#排序函数-sort" class="headerlink" title="排序函数 -sort"></a>排序函数 -sort</h2><p>语法: <code>Sort(start,end,cmp)</code></p><p>语法实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;  &#x2F;&#x2F;sort的库</span><br><span class="line">bool cmp(int a,int b)&#123;</span><br><span class="line"> return a&gt;b;     &#x2F;&#x2F;从大到小，&lt;时从小到大</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10]&#123;3,456,24,56,35,36,3,35,23,57&#125;;</span><br><span class="line">sort(a,a+10，cmp);  &#x2F;&#x2F;a为数组名，a+10代表a有10个数组  ，cmp为函数名，可以自定义</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure><h2 id="交换数值函数-swap"><a href="#交换数值函数-swap" class="headerlink" title="交换数值函数 -swap"></a>交换数值函数 -swap</h2><p>语法: <code>swap(a,b)</code><br>语法实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a &#x3D; 100;</span><br><span class="line">int b &#x3D; 55;</span><br><span class="line">swap(a,b); &#x2F;&#x2F;数组swap(a[n],b[n]);</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font size=&quot;7&quot; &gt;以下代码基于VS2017运行实现&lt;/font&gt; &lt;/p&gt;
&lt;h1 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;函数默认的参</summary>
      
    
    
    
    <category term="c++" scheme="https://jiangyin0750.github.io/categories/c/"/>
    
    
    <category term="笔记" scheme="https://jiangyin0750.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="c++" scheme="https://jiangyin0750.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Next用aplayer做播放器</title>
    <link href="https://jiangyin0750.github.io/post/aplayer/aplayer-use-help/"/>
    <id>https://jiangyin0750.github.io/post/aplayer/aplayer-use-help/</id>
    <published>2020-08-07T08:28:58.934Z</published>
    <updated>2021-01-09T09:24:53.593Z</updated>
    
    <content type="html"><![CDATA[<p>aplayer是一个HTML5的音乐播放器<br>本教程对Next主题适用，其他主题未知<br>先上效果图<br><img src="https://s1.ax1x.com/2020/08/09/aovbyd.png" alt="效果图"></p><h1 id="安装aplayer插件"><a href="#安装aplayer插件" class="headerlink" title="安装aplayer插件"></a>安装aplayer插件</h1><p>在Hexo的根目录输入一下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aplayer --save  ##注意不是hexo-tag-aplayer</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>下载aplayer在Github里的开源文件，将<code>dist</code>文件放入到<code>\themes\next\source</code>里<br><img src="https://s1.ax1x.com/2020/08/09/aovoWD.png" alt="dist"></p><h2 id="新建music-js"><a href="#新建music-js" class="headerlink" title="新建music.js"></a>新建music.js</h2><p>在dist文件里新建music.js文件<br>在文件内介入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ap &#x3D; new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(&#39;aplayer&#39;),</span><br><span class="line">    audio: [</span><br><span class="line">&#123;</span><br><span class="line">        name: &#39;name&#39;,      #歌名</span><br><span class="line">        artist: &#39;artist&#39;,  #歌手</span><br><span class="line">        url: &#39;url.mp3&#39;,    #mp3的url地址</span><br><span class="line">        cover: &#39;cover.jpg&#39; #歌的封面</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>其他参数</em></strong><br>摘自<a href="https://aplayer.js.org/#/zh-Hans/">官方文档</a></p><table><thead><tr><th>名称</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td>container</td><td align="center"></td><td align="center">document.querySelector(‘.aplayer’)    播放器容器元素</td></tr><tr><td>fixed</td><td align="center">false</td><td align="center">开启吸底模式, 详情</td></tr><tr><td>mini</td><td align="center">false</td><td align="center">开启迷你模式, 详情</td></tr><tr><td>autoplay</td><td align="center">false</td><td align="center">音频自动播放</td></tr><tr><td>theme</td><td align="center">‘#b7daff’</td><td align="center">主题色</td></tr><tr><td>loop</td><td align="center">‘all’</td><td align="center">音频循环播放, 可选值: ‘all’, ‘one’, ‘none’</td></tr><tr><td>order</td><td align="center">‘list’</td><td align="center">音频循环顺序, 可选值: ‘list’, ‘random’</td></tr><tr><td>preload</td><td align="center">‘auto’</td><td align="center">预加载，可选值: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>volume</td><td align="center">0.7</td><td align="center">默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</td></tr><tr><td>audio</td><td align="center">-</td><td align="center">音频信息, 应该是一个对象或对象数组</td></tr><tr><td>audio.name</td><td align="center">-</td><td align="center">音频名称</td></tr><tr><td>audio.artist</td><td align="center">-</td><td align="center">音频艺术家</td></tr><tr><td>audio.url</td><td align="center">-</td><td align="center">音频链接</td></tr><tr><td>audio.cover</td><td align="center">-</td><td align="center">音频封面</td></tr><tr><td>audio.lrc</td><td align="center">-</td><td align="center">详情</td></tr><tr><td>audio.theme</td><td align="center">-</td><td align="center">切换到此音频时的主题色，比上面的 theme 优先级高</td></tr><tr><td>audio.type</td><td align="center">‘auto’</td><td align="center">可选值: ‘auto’, ‘hls’, ‘normal’ 或其他自定义类型, 详情</td></tr><tr><td>customAudioType</td><td align="center">-</td><td align="center">自定义类型，详情</td></tr><tr><td>mutex</td><td align="center">true</td><td align="center">互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器</td></tr><tr><td>lrcType</td><td align="center">0</td><td align="center">详情</td></tr><tr><td>listFolded</td><td align="center">false</td><td align="center">列表默认折叠</td></tr><tr><td>listMaxHeight</td><td align="center">-</td><td align="center">列表最大高度</td></tr><tr><td>storageName</td><td align="center">‘aplayer-setting’</td><td align="center">存储播放器设置的 localStorage key</td></tr></tbody></table><p>前面带有audio标签的为<code>audio[&#123;&#125;]</code>里面的参数，不带audio的则在<code>audio[&#123;&#125;]</code>外面使用</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const ap &#x3D; new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(&#39;aplayer&#39;),</span><br><span class="line">    fixed: true,   #吸底模式</span><br><span class="line">    autoplay: false,  #自动播放</span><br><span class="line">    audio: [</span><br><span class="line"> &#123;</span><br><span class="line">name: &#39;secret base ~君がくれたもの~&#39;,</span><br><span class="line">artist: &#39;茅野愛衣 &#x2F; 戸松遥 &#x2F; 早見沙織&#39;,</span><br><span class="line">url: &#39;http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;33911781.mp3&#39;,</span><br><span class="line">cover: &#39;http:&#x2F;&#x2F;p1.music.126.net&#x2F;daZcHVIJicL3wXJWMIjAng&#x3D;&#x3D;&#x2F;7926379325753633.jpg?&#39;,</span><br><span class="line">    lrc: &#39;images&#x2F;.lrc&#39; #歌词播放并不好看，所以没有使用</span><br><span class="line"> &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="歌曲参数获取"><a href="#歌曲参数获取" class="headerlink" title="歌曲参数获取"></a>歌曲参数获取</h1><p>这里用到的url地址均为网易云音乐的</p><h2 id="mp3文件url"><a href="#mp3文件url" class="headerlink" title="mp3文件url"></a>mp3文件url</h2><p><img src="https://s1.ax1x.com/2020/08/09/aovIJO.png" alt="mp3"><br>只需要将网页id覆盖到文本url里的id里即可</p><h2 id="封面url"><a href="#封面url" class="headerlink" title="封面url"></a>封面url</h2><p>在网易云音乐的歌词界面打开控制台(F12)<br>如何点击控制台里左上角箭头<br><img src="https://s1.ax1x.com/2020/08/09/aovHQH.png" alt="箭头"><br>将箭头指向图片，然后控制台会出现图片的url<br><img src="https://s1.ax1x.com/2020/08/09/aov7Se.png" alt="图片url"><br>在图中注释的url地址右击，点击第一个<code>Open in new tab</code><br>将网址中最后的<code>param=数字y数字</code>删去，再复制粘贴即可</p><h2 id="添加歌词"><a href="#添加歌词" class="headerlink" title="添加歌词"></a>添加歌词</h2><p>添加歌词一共三种方式，推荐使用lrc文件的方式<br>在控制台的Network里面,找到一个以<code>lyric？</code>开头的文件<br><img src="https://s1.ax1x.com/2020/08/09/aovqOA.png" alt="歌词"><br>找到后右击点击<code>copy</code>里的<code>copy response</code>，没有外copy层可以直接点<code>copy response</code>’<br>点击上排的Console，输入如图指令<br><img src="https://s1.ax1x.com/2020/08/09/aovOeI.png" alt="赋值"><br><code>a</code>可以为任何英文字母，可以理解为变量赋值<br><code>=</code>后面的为粘贴内容<br>然后介入<code>a.lrc.lyric</code>输出的是原版字幕，再介入<code>a.tlyric.lyric</code>，输出的是中文字幕<br>将输出的内容放入到一个.lrc的文件里再放到<code>themes\next\source\images</code>文件夹里，在audio的参数里介入images/.lrc，也要在audio参数外加入<code>lrcType: 3</code></p><p>本文讲的东西并不多，详细移步<a href="https://aplayer.js.org/#/zh-Hans/">官方文档</a><br>添歌词的另外两种方法文档里就有</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;aplayer是一个HTML5的音乐播放器&lt;br&gt;本教程对Next主题适用，其他主题未知&lt;br&gt;先上效果图&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/09/aovbyd.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装ap</summary>
      
    
    
    
    <category term="aplayer" scheme="https://jiangyin0750.github.io/categories/aplayer/"/>
    
    
    <category term="aplayer" scheme="https://jiangyin0750.github.io/tags/aplayer/"/>
    
    <category term="教程" scheme="https://jiangyin0750.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://jiangyin0750.github.io/post/markdown/Markdown-use/"/>
    <id>https://jiangyin0750.github.io/post/markdown/Markdown-use/</id>
    <published>2020-07-30T11:50:26.830Z</published>
    <updated>2021-03-20T11:54:18.312Z</updated>
    
    <content type="html"><![CDATA[<p>markdown支持html语言，因此如果markdown没有的语法可以使用html来代替</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>以次类推，最高六级。<br /><strong>注:#号后均有空格</strong></p><h2 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><hr><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><p>加粗：左右分别用两个<em>包起来<br>斜体：左右分别用一个</em>包起来<br>斜体加粗：左右分别用三个*包起来<br>删除线：左右分别用两个~包起来</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h3 id="效果示例-1"><a href="#效果示例-1" class="headerlink" title="效果示例"></a>效果示例</h3><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><hr><h1 id="多级引用"><a href="#多级引用" class="headerlink" title="多级引用"></a>多级引用</h1><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><p>未发现&gt;有极限值<br>##效果示例</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote><hr><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>用三个或三个以上的*,-,_都可以</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">****</span><br><span class="line">--- </span><br><span class="line">---- </span><br><span class="line">___</span><br><span class="line">____</span><br></pre></td></tr></table></figure><h2 id="效果示例-2"><a href="#效果示例-2" class="headerlink" title="效果示例"></a>效果示例</h2><hr><hr><hr><hr><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[超链接名字](超链接地址 &quot;超链接title&quot;(可有可无))</span><br></pre></td></tr></table></figure><h2 id="效果示例-3"><a href="#效果示例-3" class="headerlink" title="效果示例"></a>效果示例</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Github](https:&#x2F;&#x2F;github.com&#x2F;)</span><br><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/">Github</a><br><a href="https://www.baidu.com/">百度</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>markdown语法支持html，因此也可以使用html写超链接</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;jiangyin0750.github.io&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;史蒂芬森的小屋&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="史蒂芬森的小屋"><a href="#史蒂芬森的小屋" class="headerlink" title="史蒂芬森的小屋"></a><a href="https://jiangyin0750.github.io/" target="_blank">史蒂芬森的小屋</a></h2><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">每个- + *与字中间都有空格</span><br></pre></td></tr></table></figure><h3 id="效果示例-4"><a href="#效果示例-4" class="headerlink" title="效果示例"></a>效果示例</h3><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 内容</span><br><span class="line">4个空格 -内容</span><br></pre></td></tr></table></figure><h3 id="效果示例-5"><a href="#效果示例-5" class="headerlink" title="效果示例"></a>效果示例</h3></li></ul><ul><li>1.<ul><li>a.</li><li>b.        </li><li>c.        </li></ul></li></ul><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行-分割表头和内容</span><br><span class="line">-的个数无要求</span><br></pre></td></tr></table></figure><h2 id="效果示例-6"><a href="#效果示例-6" class="headerlink" title="效果示例"></a>效果示例</h2><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1|2|3</span><br><span class="line">---|:--:|---:</span><br><span class="line">123|234|567</span><br><span class="line">789|135|178</span><br></pre></td></tr></table></figure><table><thead><tr><th>1</th><th align="center">2</th><th align="right">3</th></tr></thead><tbody><tr><td>123</td><td align="center">234</td><td align="right">567</td></tr><tr><td>789</td><td align="center">135</td><td align="right">178</td></tr></tbody></table><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h2><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure><h3 id="效果示例-7"><a href="#效果示例-7" class="headerlink" title="效果示例"></a>效果示例</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;iostream&#96;</span><br></pre></td></tr></table></figure><p><code>iostream</code></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">代码内容</span><br><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">使用时将()去除</span><br></pre></td></tr></table></figure><h3 id="效果示例-8"><a href="#效果示例-8" class="headerlink" title="效果示例"></a>效果示例</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown使用反斜线()进行特殊字符转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Markdown 支持以下这些符号前面加上反斜杠(\)来帮助插入普通的符号：</span><br><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">title可有可无，如果有加空格</span><br></pre></td></tr></table></figure><h2 id="效果示例-9"><a href="#效果示例-9" class="headerlink" title="效果示例"></a>效果示例</h2><p>实例代码<br><code>![代码块](http://lc-PxV7UWpY.cn-n1.lcfile.com/88637d709890c63c45ef/iostream.png)</code><br><img src="http://lc-pxv7uwpy.cn-n1.lcfile.com/88637d709890c63c45ef/iostream.png" alt="代码块"></p><h2 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h2><p>图片的URL可以用LeanCLoud上传.不过也有更好的图床</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>Hexo默认不支持Markdown语法的流程图,在hexo的根目录上输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)flow   </span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">(&#96;&#96;&#96;)    使用删()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="语法讲解"><a href="#语法讲解" class="headerlink" title="语法讲解"></a>语法讲解</h3><p>以<code>st=&gt;start</code>为例:st为变量名,start为操作模块名，冒号后面为显示的标题。标题与冒号之间有空格<br>标题后面也可以加超链接如<code>st=&gt;start: 开始:&gt;https://www.baidu.com/</code>点图标跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 跳转:&gt;https:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br><span class="line">ed&#x3D;&gt;end: 123</span><br><span class="line">st-&gt;ed</span><br></pre></td></tr></table></figure><p><strong>所有操作模块名</strong></p><table><thead><tr><th>操作模块</th><th align="center">说明</th></tr></thead><tbody><tr><td>start</td><td align="center">开始</td></tr><tr><td>end</td><td align="center">结束</td></tr><tr><td>opration</td><td align="center">普通操作块</td></tr><tr><td>condition</td><td align="center">判断块</td></tr><tr><td>subroutine</td><td align="center">子任务块</td></tr><tr><td>inputoutput</td><td align="center">输入输出块</td></tr></tbody></table><p><code>st-&gt;op-&gt;cond</code>中用变量名指向另一个变量名-&gt;≈箭头<br><code>cond(yes)-&gt;e</code> <code>cond(no)-&gt;op</code>这两个中的yes,no只能用英文。类似if判断</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;markdown支持html语言，因此如果markdown没有的语法可以使用html来代替&lt;/p&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="markdown" scheme="https://jiangyin0750.github.io/categories/markdown/"/>
    
    
    <category term="markdown" scheme="https://jiangyin0750.github.io/tags/markdown/"/>
    
    <category term="笔记" scheme="https://jiangyin0750.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jiangyin0750.github.io/post/uncategorized/hello-world/"/>
    <id>https://jiangyin0750.github.io/post/uncategorized/hello-world/</id>
    <published>2020-07-24T06:14:08.976Z</published>
    <updated>2021-03-20T11:55:23.950Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
