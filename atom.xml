<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>史蒂芬森的小屋</title>
  
  
  <link href="https://jiangyin0750.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiangyin0750.github.io/"/>
  <updated>2021-01-10T02:26:53.835Z</updated>
  <id>https://jiangyin0750.github.io/</id>
  
  <author>
    <name>史蒂芬森</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++学习笔记</title>
    <link href="https://jiangyin0750.github.io/post/c/c++%20study/"/>
    <id>https://jiangyin0750.github.io/post/c/c++%20study/</id>
    <published>2020-08-25T02:41:12.459Z</published>
    <updated>2021-01-10T02:26:53.835Z</updated>
    
    <content type="html"><![CDATA[<p><font size="7" >以下代码基于VS2017运行实现</font> </p><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>函数默认的参数，调用函数可以不传参，如果传入参数则覆盖默认值</strong><br>书写规则: 从右到左进行判断，如果右边的参数没有默认值，则左边的参数无法拥有默认值<br>定义函数时可以不定义参数名，写函数体时也可以不定义，但是无法使用默认值<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a,int &#x3D; 3,int &#x3D; 10) &#x2F;&#x2F;定义函数</span><br><span class="line">void chat(int a,int b,int c) &#x2F;&#x2F;写函数体时，可以使用上面的格式，但是使用了就无法当参数进行使用</span><br></pre></td></tr></table></figure><p>定义示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void chat1 (int &#x3D; 2,int &#x3D; 10,int &#x3D; 20) &#x2F;&#x2F;不报错</span><br><span class="line">void chat1 (int ,int &#x3D; 10,int c) &#x2F;&#x2F;不报错</span><br><span class="line">void chat1 (int &#x3D; 2,int &#x3D; 10,int c) &#x2F;&#x2F;报错</span><br><span class="line">void chat1 (int &#x3D; 2,int b,int &#x3D; 20) &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure><hr><h1 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h1><p><strong>函数名一致，参数不同</strong><br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a, int b, int c);</span><br><span class="line">void chat(string b, string c);</span><br></pre></td></tr></table></figure><p>如果函数的参数不一样，但是传入的参数类型一致也会报错<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void chat(int a, int &#x3D; 3, int &#x3D; 10); &#x2F;&#x2F;后两个默认参数，无需传入</span><br><span class="line">void chat(int b, string &#x3D; &quot;345&quot;);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    chat(1);     &#x2F;&#x2F;报错E0308 ,多个重载函数chat实例与参数列表匹配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注-同一类型的加-amp-与不加-amp-编译器无法识别"><a href="#注-同一类型的加-amp-与不加-amp-编译器无法识别" class="headerlink" title="注:同一类型的加&amp;与不加&amp;编译器无法识别"></a><strong>注:同一类型的加&amp;与不加&amp;编译器无法识别</strong></h2><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p><strong>可以自己判别数据的类型，不需要把相同的内容的函数，因为传入类型的不同而写很多个函数体</strong><br>函数模板定义形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename 类型参数1，typename 类型参数2&gt;  &#x2F;&#x2F;typename可以改为class</span><br><span class="line">返回值类型 函数名()&#123;</span><br><span class="line">  &#x2F;&#x2F;函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用函数模板写一个交换函数为例，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;  void Sort(T &amp;a, T &amp;b);</span><br><span class="line">int main() &#123;</span><br><span class="line">double a, b;</span><br><span class="line">cout &lt;&lt; &quot;输入内容&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; &quot;输入内容&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">Sort(a,b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; </span><br><span class="line">void Sort(T &amp;a, T &amp;b) &#123;</span><br><span class="line">T temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把double类型换为int，string，float，最终换位都会成功</p><p><strong>显式具体化</strong><br>可以判断传参的类型并且为这个类型的参数写的一个独立定义<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;  void Sort(T &amp;a, T &amp;b);</span><br><span class="line">struct abc &#123;     &#x2F;&#x2F;定义一个名为abc的结构体</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;&gt; void Sort&lt;abc&gt;(abc &amp;a, abc &amp;b);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">abc a&#123; 10,20 &#125;, b&#123;20,10&#125;;</span><br><span class="line">Sort(a,b);  &#x2F;&#x2F;传abc类型的数据</span><br><span class="line">int c, d;</span><br><span class="line">c &#x3D; 1;</span><br><span class="line">d &#x3D; 5;</span><br><span class="line">Sort(c,d);  &#x2F;&#x2F;传int类型的数据</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; </span><br><span class="line">void Sort(T &amp;a, T &amp;b) &#123;</span><br><span class="line">T temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;&gt; void Sort&lt;abc&gt; (abc &amp;a,abc &amp;b) &#123;   &#x2F;&#x2F;如果遇到参数abc类型此函数优先</span><br><span class="line">cout &lt;&lt; &quot;12345&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;template&lt;&gt; void Sort&lt;abc&gt; (abc &amp;a,abc &amp;b)也可以写为template&lt;&gt; void Sort (abc &amp;a,abc &amp;b)</span><br></pre></td></tr></table></figure><hr><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p><strong>五种变量储存方式</strong></p><table><thead><tr><th>存储描述</th><th align="center">持续性</th><th align="right">作用域</th><th align="right">链接性</th><th align="right">声明</th></tr></thead><tbody><tr><td>自动</td><td align="center">自动</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中</td></tr><tr><td>寄存器</td><td align="center">自动</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中，使用关键字register</td></tr><tr><td>静态，无链接性</td><td align="center">静态</td><td align="right">代码块</td><td align="right">无</td><td align="right">在代码块中，使用关键字static</td></tr><tr><td>静态，外部链接性</td><td align="center">自动</td><td align="right">文件</td><td align="right">外部</td><td align="right">不在任何函数内</td></tr><tr><td>静态，内部链接性</td><td align="center">自动</td><td align="right">文件</td><td align="right">内部</td><td align="right">不在任何函数内，使用关键字static</td></tr></tbody></table><h2 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h2><p>c++提供了两种变量声明，一是定义声明，他给变量分配内存；另一种是引用声明，他不给变量分配内存，因为他引用已有变量<br>引用声明使用关键字<code>extren</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; file1.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">extern int a; &#x2F;&#x2F;引用file2中名为a 的变量</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; file2.cpp</span><br><span class="line">int a &#x3D; 10;</span><br></pre></td></tr></table></figure><p>控制台输出为10</p><h2 id="栈区与堆区"><a href="#栈区与堆区" class="headerlink" title="栈区与堆区"></a>栈区与堆区</h2><p>栈区:由系统进行内存的管理。<br>堆区:由程序员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。<br>堆区申请可用new关键字<br>对比示例：<br><strong>1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">int a &#x3D; 10;  &#x2F;&#x2F;栈区的变量</span><br><span class="line">return &amp;a; &#x2F;&#x2F;返回一个即将被释放内存的地址</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; func();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;在vs2017中输出为10 ，因编译器而异</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;输出为非10的数</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">int *a &#x3D; new int(10);  &#x2F;&#x2F;new一个堆区的变量</span><br><span class="line">&#x2F;&#x2F;new返回的是一个指针类型，所以要用*来接收</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int *p;</span><br><span class="line">p &#x3D; func();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F;三次输出都为10</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;delete(p);   释放p的内存，运行会出错，前两行依旧可以输出</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>通过定义一种新的声明区域来创建命名的名称空间，为了让一个名称空间中的名称不会与另一个名称空间里的相同名发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西<br>关键词: <code>namespace </code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;file.h</span><br><span class="line">namespace Myfspace    &#x2F;&#x2F;定义一个名为Myfspace的名称空间</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void print()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;输出&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Mysspace</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域解析运算符"><a href="#作用域解析运算符" class="headerlink" title="作用域解析运算符::"></a>作用域解析运算符::</h2><p>示例：</p><ul><li>Myfspace::c;</li></ul><ul><li>Mysspace::c;</li></ul><ul><li>Myfspace::swap();</li></ul><h2 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h2><p>using声明是特定的标识符可用，using编译指令是整个名称空间可用<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;上面file.h也算这堆代码内</span><br><span class="line">&#x2F;&#x2F;file1.cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;file.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace Myfspace;  &#x2F;&#x2F;using编译指令</span><br><span class="line">using namespace Mysspace;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;using Myfspace::c;  &#x2F;&#x2F;using声明，只可使用c</span><br><span class="line">int a, b;</span><br><span class="line">a &#x3D; 10;</span><br><span class="line">b &#x3D; 20;</span><br><span class="line">c &#x3D; 11.11;&#x2F;&#x2F;报错c不明确,解决方法：改为Myfspace::c; 或 Mysspace::c;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">swap(a, b);  &#x2F;&#x2F;调用Myfspace中的swap函数</span><br><span class="line">Mysspace::print();&#x2F;&#x2F;调用Mysspace中print函数   Mysspace::可加可不加</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot;     &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="名称空间嵌套"><a href="#名称空间嵌套" class="headerlink" title="名称空间嵌套"></a>名称空间嵌套</h2><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">namespace Myfspace</span><br><span class="line">&#123;</span><br><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">namespace Mysspace</span><br><span class="line">&#123;</span><br><span class="line">void printout()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;这里是Mysspace空间&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时的Mysspace用using编译指令可表示为:</p><ul><li>using namespace Mysspace;</li></ul><ul><li>using namespace Myfspace::Mysspace;</li></ul><p><strong>名称空间的别名</strong><br>可用来简化嵌套的名称空间<br>语法: namespace &lt;别名&gt; = &lt;原名&gt;;<br>示例: <code>namespace T_space = Mysspace;</code></p><p><strong>无名的名称空间</strong><br>可以当作链接性为内部的静态变量<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">namespace     &#x2F;&#x2F;本名称空间无法在这个文件以外使用</span><br><span class="line">&#123;</span><br><span class="line">int c &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类是面向对象设计实现信息封装的基础，类的实例称为对象<br>类三大特性：</p><ul><li>封装性: 将私有成员进行隐藏，外部通过接口对成员进行修改</li></ul><ul><li>继承性: 节省重复代码</li></ul><ul><li>多态性: 同一操作对不同的类对象的结果不同</li></ul><h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:       &#x2F;&#x2F;公开权限，类内外皆可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">private:      &#x2F;&#x2F;私有权限，类内可访问，类外不可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">protected:    &#x2F;&#x2F;保护权限，类内可访问，类外不可访问</span><br><span class="line">属性&#x2F;行为</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">&#x2F;&#x2F;file.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int name;  &#x2F;&#x2F;权限外的变量默认为私有，类外无法访问</span><br><span class="line">public:       &#x2F;&#x2F;公开权限，类内外皆可访问</span><br><span class="line">int pu_ages;</span><br><span class="line">void hpp();</span><br><span class="line">void showifmt()      </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pu_ages;</span><br><span class="line">&#125;</span><br><span class="line">private:      &#x2F;&#x2F;私有权限，类内可访问，类外不可访问</span><br><span class="line">int pri_ages;</span><br><span class="line">void showpri()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pri_ages;</span><br><span class="line">&#125;</span><br><span class="line">protected:    &#x2F;&#x2F;保护权限，类内可访问，类外不可访问</span><br><span class="line">int pro_ages;</span><br><span class="line">void showpro()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pro_ages;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person P1;</span><br><span class="line">cin &gt;&gt; P1.pu_ages;  &#x2F;&#x2F;写入P1的pu_ages属性值;</span><br><span class="line">P1.showifmt(); &#x2F;&#x2F;调用P1的方法showinmt</span><br><span class="line">&#x2F;&#x2F;P1.pro_ages;  &#x2F;&#x2F;错误E0265,成员所声明行不可访问</span><br><span class="line">&#x2F;&#x2F;P1.pri_ages;  &#x2F;&#x2F;错误如上</span><br><span class="line">&#x2F;&#x2F;P1.showpro(); &#x2F;&#x2F;错误如上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装特性体现:<br>public一般用来写方法，当作接口使用，可以用来对私有的数据进行修改;<br>private一般用来存数据，防止数据被修改</p><p><strong>struct和class的区别</strong><br>struct的默认权限是<code>public</code>的,class默认权限<code>private</code>的，其他大致一致</p><p><strong>实现类成员函数</strong></p><ul><li>定义成员函数时，使用作用域运算符<code>::</code>来标识函数所属的类</li></ul><ul><li>类方法可以访问类的private组件</li></ul><p><code>void person::hpp()</code>可在类外写函数主体，在类内需要声明，无论类内是什么作用域下都可以在类外写主体</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>构造函数分类：</p><ul><li>无参构造函数(默认不书写构造函数自动生成空函数)</li></ul><ul><li>有参构造函数：1.普通有参构造函数  2.拷贝构造函数</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设有一个person类</span><br><span class="line"></span><br><span class="line">person()   &#x2F;&#x2F;无参构造函数  未书写构造函数时默认生成空此函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(int value)  &#x2F;&#x2F;普通有参构造函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;2&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(const person&amp; p)  &#x2F;&#x2F;有参拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line"> cout&lt;&lt;&quot;3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数被调用时机</p><ul><li>person P1      //无参构</li></ul><ul><li>person P2(10)  //有参构</li></ul><ul><li>person P3(p1)  //拷贝构</li></ul><p>假设以上代码可运行，则结果为依次输出1 2 3</p><p>调用构造函数风格:<br>以下代码基于person.cpp中，且两种等价</p><ul><li>显示地调用构造函数<code>person P1 = person(&quot;Myname&quot;)</code></li></ul><ul><li>隐式<code>person P1(&quot;Myname&quot;)</code>     </li></ul><p><strong>成员初始化列表</strong></p><p>可以将类中的非静态const变量赋初值<br>语法:<code>&lt;类名&gt;(传入参数):类成员(传入参数)</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int a,int b):age(a),len(b),c(a)&#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int age;</span><br><span class="line">const int len;</span><br><span class="line">int &amp;c;   &#x2F;&#x2F;引用数据类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化工作是在对象创建时完成的，此时还未执行括号里的任何代码</strong></p><p>成员初始化列表注意:</p><ul><li>这种格式只能用于构造函数</li></ul><ul><li>必须用这种格式来初始化非静态const变量</li></ul><ul><li>必须用这种格式来初始化引用数据类型</li></ul><p>注意事项:<br>1.不要把类成员名当作构造函数的的参数名，会引起混乱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">person.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name)</span><br><span class="line">&#123;</span><br><span class="line">name &#x3D; name        &#x2F;&#x2F;可以用加入前缀或后缀。this指针也可以解决问题</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;123&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果未给类提供构造函数，则编译器会生成默认构造函数，但如果写了构造函数，则必须提供无参构造函数，不然会报错</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象过期时，程序会自动调用析构函数，析构函数用来完成清理工作。<br>特点：析构函数没有参数，返回值和声明类型<br>语法<code>~&lt;类名&gt;</code>，如<code>~person</code></p><p>析构函数被调用时机</p><ul><li>对象过期时</li></ul><ul><li>delele时(仅限于new出来的对象)</li></ul><p>如person.cpp中的代码将会在程序结束时输出123</p><p>与构造函数一样，如果类中没有书写构造函数，编译器也会生成默认析构函数</p><p><strong>C++11 列表初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person::person(const std::string &amp; co, long n &#x3D; 0, double pr &#x3D; 0;)</span><br><span class="line">person P1 &#x3D; &#123; &quot;Smicth&quot; &#125;;    &#x2F;&#x2F;P1默认参数0，0</span><br><span class="line">person P2 &#x3D; &#123; &quot;Mark&quot;,100,10.5 &#125;;    &#x2F;&#x2F;P2不使用默认参数</span><br><span class="line"> 和括号传参结果无区别</span><br></pre></td></tr></table></figure><p><strong>const成员函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Stock()</span><br><span class="line">&#123;</span><br><span class="line">int ages;</span><br><span class="line">public:</span><br><span class="line">Stock(int temp)</span><br><span class="line">&#123;</span><br><span class="line">ages &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void show() &#x2F;&#x2F;const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ages &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const P1(10);</span><br><span class="line">P1.show();&#x2F;&#x2F;错误E1086   因为编译器无法确保调用对象不被修改  只需在函数后面加一个const</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每一个对象都能通过this指针来访问自己的地址。this指针是所有成员函数的隐含参数。<br>因此在成员函数内部,它可以用来指向调用对象</p><p>如上面的person.cpp的构造函数因为名称冲突而造成了混论，无法赋初值，而this指针则可以解决这个问题</p><h3 id="this实现链式编程"><a href="#this实现链式编程" class="headerlink" title="this实现链式编程"></a>this实现链式编程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">int abc;</span><br><span class="line">public:</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">abc &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">person &amp;Add()</span><br><span class="line">&#123;</span><br><span class="line">abc +&#x3D; 10;</span><br><span class="line">return *this;    &#x2F;&#x2F;用*运算符将p1以p1文字形式返回回去</span><br><span class="line">&#125;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; abc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">p1.Add().Add();     &#x2F;&#x2F; 连续调用两次Add函数，第一次调用返回回来一个p1，从而实现再次调用</span><br><span class="line">p1.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为30</span><br></pre></td></tr></table></figure><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>定义语法:<code>&lt;类名&gt; &lt;变量名&gt;[元素数]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</code><br>如：<br>假设有一有参构造函数,有一个ages属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person value[3]&#123;</span><br><span class="line">&#123;2&#125;,    &#x2F;&#x2F;ages属性赋值，下同</span><br><span class="line">&#123;2&#125;,</span><br><span class="line">&#123;1&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cout&lt;&lt;value[0].ages;</span><br></pre></td></tr></table></figure><h3 id="静态成员变量和函数"><a href="#静态成员变量和函数" class="headerlink" title="静态成员变量和函数"></a>静态成员变量和函数</h3><p>对象成员函数是每个对象独立的内存，而静态成员函数则是共享一段内存<br>静态成员变量特点：</p><ul><li>类内声明，类外初始化</li></ul><ul><li>所有对象共享同一份数据</li></ul><ul><li>在编译阶段分配内存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;static.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int M_B &#x3D; 10;</span><br><span class="line">static int M_A;    &#x2F;&#x2F;注意:类内禁止赋值</span><br><span class="line">static void func();</span><br><span class="line">&#125;</span><br><span class="line">int person::M_A &#x3D; 10；     &#x2F;&#x2F;类外初始化</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person P1;</span><br><span class="line">person P2;</span><br><span class="line">cout &lt;&lt; P1.M_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; P2.M_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">输出结果均为10</span><br></pre></td></tr></table></figure><p><strong>静态成员函数</strong></p><ul><li>程序共享一个函数</li></ul><ul><li>静态成员函数只能访问静态成员变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static01.cpp</span><br><span class="line">void person::func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; M_A &lt;&lt; endl;&#x2F;&#x2F;静态成员变量可被访问</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; M_B &lt;&lt; endl;     &#x2F;&#x2F;非静态成员变量无法被访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h1><p>重载运算符可以实现自以定类型的四则运算以及类似int类型的比大小功能<br>重载运算符是c++形式的一种多态<br>c++中可重载运算符</p><table><thead><tr><th>运算符类型</th><th align="center">可重载</th></tr></thead><tbody><tr><td>双目算术运算符</td><td align="center">+ ，-，*，/，%</td></tr><tr><td>关系运算符</td><td align="center">==，!= ，&lt; ，&gt; ，&lt;=，&gt;=</td></tr><tr><td>逻辑运算符</td><td align="center">||，&amp;&amp;，!</td></tr><tr><td>单目运算符</td><td align="center">+ ，-，*，&amp;</td></tr><tr><td>自增自减运算符</td><td align="center">++，–</td></tr><tr><td>位运算符</td><td align="center">&amp;，~，^,，&lt;&lt; ，&gt;&gt;，|</td></tr><tr><td>赋值运算符</td><td align="center">=, +=, -=, *=, /= , % = , &amp;=,</td></tr><tr><td>空间申请与释放</td><td align="center">new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td align="center">()，-&gt;，,，[]</td></tr></tbody></table><p>语法：<code>&lt;返回值类型&gt;operator&lt;运算符&gt;(参数)</code></p><h2 id="实现自以定的类型相加并输出示例："><a href="#实现自以定的类型相加并输出示例：" class="headerlink" title="实现自以定的类型相加并输出示例："></a>实现自以定的类型相加并输出示例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;text.h</span><br><span class="line">class text</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">text operator+(text &amp;a)   </span><br><span class="line">&#123;</span><br><span class="line">text temp;   &#x2F;&#x2F;创建一个临时变量</span><br><span class="line">temp.M_A &#x3D; M_A + a.M_A;</span><br><span class="line">temp.M_B &#x3D; M_B + a.M_B;</span><br><span class="line">return temp;  &#x2F;&#x2F;返回临时变量</span><br><span class="line">&#125;</span><br><span class="line">text()&#123;&#125;</span><br><span class="line">void operator&lt;&lt;(ostream &amp;os)  &#x2F;&#x2F;重载&lt;&lt;运算符，ostream是标准输出流</span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; &quot;M_A:&quot; &lt;&lt; M_A &lt;&lt; &quot;   &quot; &lt;&lt; &quot;M_B:&quot; &lt;&lt; M_B;</span><br><span class="line">&#125;</span><br><span class="line">text(int a, int b)  &#x2F;&#x2F;有参构造</span><br><span class="line">&#123;</span><br><span class="line">M_A &#x3D; a;</span><br><span class="line">M_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int M_A;</span><br><span class="line">int M_B;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;main.cpp</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text a(10,10);</span><br><span class="line">text b(10,10);</span><br><span class="line">text c;</span><br><span class="line">c &#x3D; a + b;   &#x2F;&#x2F;与c &#x3D; a.operator+(b);同义</span><br><span class="line">c &lt;&lt; cout;   &#x2F;&#x2F;与c.operator&lt;&lt;(cout);同义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c&lt;&lt;cout</code>；是在类内重载&lt;&lt;运算符的，本质是调用函数，与<code>cout&lt;&lt;c</code>相比看起来有一点怪<br>可以用全局重载&lt;&lt;解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在main.cpp加入</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;cout,text &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;M_A:&quot; &lt;&lt; p.M_A &lt;&lt; &quot;M_B:&quot; &lt;&lt; p.M_B;</span><br><span class="line">return cout;   &#x2F;&#x2F;把cout当作返回值返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在class类中声明此函数为友元函数即添加一行<code>friend ostream &amp; operator&lt;&lt;(ostream &amp;cout, text &amp;p);</code><br>此版本可实现类似<code>cout&lt;&lt;c&lt;&lt;endl;</code>的实现<br>在全局重载&lt;&lt;,<code>cout&lt;&lt;c;</code>与<code>operator&lt;&lt;(cout,c);</code>同义<br>返回cout的意义是让<code>cout&lt;&lt;c</code>变为返回的cout从而继续实现下一步</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>将自以定的类型赋值给标准类型如<code>double a = p1;</code>(假设p1是一个类对象)<br>也可以将自以定类型赋值给自以定类型如<code>text a = p1;</code>(假设a和p1非同一类的对象)<br>可以通过重载<code>=</code>运算符实现相同效果<br>语法:<code>operator &lt;转换目标类型&gt;()</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">person1.h</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int a):age(a)&#123;&#125;;</span><br><span class="line">operator double()&#123;return age;&#125;;</span><br><span class="line">private:</span><br><span class="line">double age;</span><br><span class="line">&#125;;</span><br><span class="line">file.cpp</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">double a &#x3D; p1;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:10</span><br></pre></td></tr></table></figure><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>友元有三种:</p><ul><li>友元函数</li></ul><ul><li>友元类</li></ul><ul><li>友元成员函数</li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。<br>只需在函数原型写入类声明中并在最前面加入<code>friend</code>，该函数就是该类的友元函数<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">friend.cpp</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">friend void show(person &amp;p);  &#x2F;&#x2F;友元函数不是类的成员，所以不需要在意是否是public作用域</span><br><span class="line">int age;</span><br><span class="line">&#125;</span><br><span class="line">void show(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中声明为友元函数后，便可以访问类中private作用域下的成员。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>待补~</p><h2 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h2><p>待补~</p><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="排序函数-sort"><a href="#排序函数-sort" class="headerlink" title="排序函数 -sort"></a>排序函数 -sort</h2><p>语法: <code>Sort(start,end,cmp)</code></p><p>语法实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;  &#x2F;&#x2F;sort的库</span><br><span class="line">bool cmp(int a,int b)&#123;</span><br><span class="line"> return a&gt;b;     &#x2F;&#x2F;从大到小，&lt;时从小到大</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10]&#123;3,456,24,56,35,36,3,35,23,57&#125;;</span><br><span class="line">sort(a,a+10，cmp);  &#x2F;&#x2F;a为数组名，a+10代表a有10个数组  ，cmp为函数名，可以自定义</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure><h2 id="交换数值函数-swap"><a href="#交换数值函数-swap" class="headerlink" title="交换数值函数 -swap"></a>交换数值函数 -swap</h2><p>语法: <code>swap(a,b)</code><br>语法实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a &#x3D; 100;</span><br><span class="line">int b &#x3D; 55;</span><br><span class="line">swap(a,b); &#x2F;&#x2F;数组swap(a[n],b[n]);</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font size=&quot;7&quot; &gt;以下代码基于VS2017运行实现&lt;/font&gt; &lt;/p&gt;
&lt;h1 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;函数默认的参</summary>
      
    
    
    
    <category term="c++" scheme="https://jiangyin0750.github.io/categories/c/"/>
    
    
    <category term="笔记" scheme="https://jiangyin0750.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="c++" scheme="https://jiangyin0750.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Next用aplayer做播放器</title>
    <link href="https://jiangyin0750.github.io/post/aplayer/aplayer-use-help/"/>
    <id>https://jiangyin0750.github.io/post/aplayer/aplayer-use-help/</id>
    <published>2020-08-07T08:28:58.934Z</published>
    <updated>2021-01-09T09:24:53.593Z</updated>
    
    <content type="html"><![CDATA[<p>aplayer是一个HTML5的音乐播放器<br>本教程对Next主题适用，其他主题未知<br>先上效果图<br><img src="https://s1.ax1x.com/2020/08/09/aovbyd.png" alt="效果图"></p><h1 id="安装aplayer插件"><a href="#安装aplayer插件" class="headerlink" title="安装aplayer插件"></a>安装aplayer插件</h1><p>在Hexo的根目录输入一下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aplayer --save  ##注意不是hexo-tag-aplayer</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>下载aplayer在Github里的开源文件，将<code>dist</code>文件放入到<code>\themes\next\source</code>里<br><img src="https://s1.ax1x.com/2020/08/09/aovoWD.png" alt="dist"></p><h2 id="新建music-js"><a href="#新建music-js" class="headerlink" title="新建music.js"></a>新建music.js</h2><p>在dist文件里新建music.js文件<br>在文件内介入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ap &#x3D; new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(&#39;aplayer&#39;),</span><br><span class="line">    audio: [</span><br><span class="line">&#123;</span><br><span class="line">        name: &#39;name&#39;,      #歌名</span><br><span class="line">        artist: &#39;artist&#39;,  #歌手</span><br><span class="line">        url: &#39;url.mp3&#39;,    #mp3的url地址</span><br><span class="line">        cover: &#39;cover.jpg&#39; #歌的封面</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><em>其他参数</em></strong><br>摘自<a href="https://aplayer.js.org/#/zh-Hans/">官方文档</a></p><table><thead><tr><th>名称</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td>container</td><td align="center"></td><td align="center">document.querySelector(‘.aplayer’)    播放器容器元素</td></tr><tr><td>fixed</td><td align="center">false</td><td align="center">开启吸底模式, 详情</td></tr><tr><td>mini</td><td align="center">false</td><td align="center">开启迷你模式, 详情</td></tr><tr><td>autoplay</td><td align="center">false</td><td align="center">音频自动播放</td></tr><tr><td>theme</td><td align="center">‘#b7daff’</td><td align="center">主题色</td></tr><tr><td>loop</td><td align="center">‘all’</td><td align="center">音频循环播放, 可选值: ‘all’, ‘one’, ‘none’</td></tr><tr><td>order</td><td align="center">‘list’</td><td align="center">音频循环顺序, 可选值: ‘list’, ‘random’</td></tr><tr><td>preload</td><td align="center">‘auto’</td><td align="center">预加载，可选值: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>volume</td><td align="center">0.7</td><td align="center">默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</td></tr><tr><td>audio</td><td align="center">-</td><td align="center">音频信息, 应该是一个对象或对象数组</td></tr><tr><td>audio.name</td><td align="center">-</td><td align="center">音频名称</td></tr><tr><td>audio.artist</td><td align="center">-</td><td align="center">音频艺术家</td></tr><tr><td>audio.url</td><td align="center">-</td><td align="center">音频链接</td></tr><tr><td>audio.cover</td><td align="center">-</td><td align="center">音频封面</td></tr><tr><td>audio.lrc</td><td align="center">-</td><td align="center">详情</td></tr><tr><td>audio.theme</td><td align="center">-</td><td align="center">切换到此音频时的主题色，比上面的 theme 优先级高</td></tr><tr><td>audio.type</td><td align="center">‘auto’</td><td align="center">可选值: ‘auto’, ‘hls’, ‘normal’ 或其他自定义类型, 详情</td></tr><tr><td>customAudioType</td><td align="center">-</td><td align="center">自定义类型，详情</td></tr><tr><td>mutex</td><td align="center">true</td><td align="center">互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器</td></tr><tr><td>lrcType</td><td align="center">0</td><td align="center">详情</td></tr><tr><td>listFolded</td><td align="center">false</td><td align="center">列表默认折叠</td></tr><tr><td>listMaxHeight</td><td align="center">-</td><td align="center">列表最大高度</td></tr><tr><td>storageName</td><td align="center">‘aplayer-setting’</td><td align="center">存储播放器设置的 localStorage key</td></tr></tbody></table><p>前面带有audio标签的为<code>audio[&#123;&#125;]</code>里面的参数，不带audio的则在<code>audio[&#123;&#125;]</code>外面使用</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const ap &#x3D; new APlayer(&#123;</span><br><span class="line">    container: document.getElementById(&#39;aplayer&#39;),</span><br><span class="line">    fixed: true,   #吸底模式</span><br><span class="line">    autoplay: false,  #自动播放</span><br><span class="line">    audio: [</span><br><span class="line"> &#123;</span><br><span class="line">name: &#39;secret base ~君がくれたもの~&#39;,</span><br><span class="line">artist: &#39;茅野愛衣 &#x2F; 戸松遥 &#x2F; 早見沙織&#39;,</span><br><span class="line">url: &#39;http:&#x2F;&#x2F;music.163.com&#x2F;song&#x2F;media&#x2F;outer&#x2F;url?id&#x3D;33911781.mp3&#39;,</span><br><span class="line">cover: &#39;http:&#x2F;&#x2F;p1.music.126.net&#x2F;daZcHVIJicL3wXJWMIjAng&#x3D;&#x3D;&#x2F;7926379325753633.jpg?&#39;,</span><br><span class="line">    lrc: &#39;images&#x2F;.lrc&#39; #歌词播放并不好看，所以没有使用</span><br><span class="line"> &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="歌曲参数获取"><a href="#歌曲参数获取" class="headerlink" title="歌曲参数获取"></a>歌曲参数获取</h1><p>这里用到的url地址均为网易云音乐的</p><h2 id="mp3文件url"><a href="#mp3文件url" class="headerlink" title="mp3文件url"></a>mp3文件url</h2><p><img src="https://s1.ax1x.com/2020/08/09/aovIJO.png" alt="mp3"><br>只需要将网页id覆盖到文本url里的id里即可</p><h2 id="封面url"><a href="#封面url" class="headerlink" title="封面url"></a>封面url</h2><p>在网易云音乐的歌词界面打开控制台(F12)<br>如何点击控制台里左上角箭头<br><img src="https://s1.ax1x.com/2020/08/09/aovHQH.png" alt="箭头"><br>将箭头指向图片，然后控制台会出现图片的url<br><img src="https://s1.ax1x.com/2020/08/09/aov7Se.png" alt="图片url"><br>在图中注释的url地址右击，点击第一个<code>Open in new tab</code><br>将网址中最后的<code>param=数字y数字</code>删去，再复制粘贴即可</p><h2 id="添加歌词"><a href="#添加歌词" class="headerlink" title="添加歌词"></a>添加歌词</h2><p>添加歌词一共三种方式，推荐使用lrc文件的方式<br>在控制台的Network里面,找到一个以<code>lyric？</code>开头的文件<br><img src="https://s1.ax1x.com/2020/08/09/aovqOA.png" alt="歌词"><br>找到后右击点击<code>copy</code>里的<code>copy response</code>，没有外copy层可以直接点<code>copy response</code>’<br>点击上排的Console，输入如图指令<br><img src="https://s1.ax1x.com/2020/08/09/aovOeI.png" alt="赋值"><br><code>a</code>可以为任何英文字母，可以理解为变量赋值<br><code>=</code>后面的为粘贴内容<br>然后介入<code>a.lrc.lyric</code>输出的是原版字幕，再介入<code>a.tlyric.lyric</code>，输出的是中文字幕<br>将输出的内容放入到一个.lrc的文件里再放到<code>themes\next\source\images</code>文件夹里，在audio的参数里介入images/.lrc，也要在audio参数外加入<code>lrcType: 3</code></p><p>本文讲的东西并不多，详细移步<a href="https://aplayer.js.org/#/zh-Hans/">官方文档</a><br>添歌词的另外两种方法文档里就有</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;aplayer是一个HTML5的音乐播放器&lt;br&gt;本教程对Next主题适用，其他主题未知&lt;br&gt;先上效果图&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/09/aovbyd.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装ap</summary>
      
    
    
    
    <category term="aplayer" scheme="https://jiangyin0750.github.io/categories/aplayer/"/>
    
    
    <category term="aplayer" scheme="https://jiangyin0750.github.io/tags/aplayer/"/>
    
    <category term="教程" scheme="https://jiangyin0750.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://jiangyin0750.github.io/post/markdown/Markdown-use/"/>
    <id>https://jiangyin0750.github.io/post/markdown/Markdown-use/</id>
    <published>2020-07-30T11:50:26.830Z</published>
    <updated>2020-12-05T12:54:17.173Z</updated>
    
    <content type="html"><![CDATA[<p>markdown支持html语言，因此如果markdown没有的语法可以使用html来代替</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>以次类推，最高六级。<br /><strong>注:#号后均有空格</strong></p><h2 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><hr><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><p>加粗：左右分别用两个<em>包起来<br>斜体：左右分别用一个</em>包起来<br>斜体加粗：左右分别用三个*包起来<br>删除线：左右分别用两个~包起来</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><h3 id="效果示例-1"><a href="#效果示例-1" class="headerlink" title="效果示例"></a>效果示例</h3><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><hr><h1 id="多级引用"><a href="#多级引用" class="headerlink" title="多级引用"></a>多级引用</h1><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><p>未发现&gt;有极限值<br>##效果示例</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote><hr><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>用三个或三个以上的*,-,_都可以</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">****</span><br><span class="line">--- </span><br><span class="line">---- </span><br><span class="line">___</span><br><span class="line">____</span><br></pre></td></tr></table></figure><h2 id="效果示例-2"><a href="#效果示例-2" class="headerlink" title="效果示例"></a>效果示例</h2><hr><hr><hr><hr><hr><hr><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[超链接名字](超链接地址 &quot;超链接title&quot;(可有可无))</span><br></pre></td></tr></table></figure><h2 id="效果示例-3"><a href="#效果示例-3" class="headerlink" title="效果示例"></a>效果示例</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Github](https:&#x2F;&#x2F;github.com&#x2F;)</span><br><span class="line">[百度](https:&#x2F;&#x2F;www.baidu.com&#x2F;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/">Github</a><br><a href="https://www.baidu.com/">百度</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>markdown语法支持html，因此也可以使用html写超链接</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;jiangyin0750.github.io&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;史蒂芬森的小屋&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="史蒂芬森的小屋"><a href="#史蒂芬森的小屋" class="headerlink" title="史蒂芬森的小屋"></a><a href="https://jiangyin0750.github.io/" target="_blank">史蒂芬森的小屋</a></h2><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">每个- + *与字中间都有空格</span><br></pre></td></tr></table></figure><h3 id="效果示例-4"><a href="#效果示例-4" class="headerlink" title="效果示例"></a>效果示例</h3><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 内容</span><br><span class="line">4个空格 -内容</span><br></pre></td></tr></table></figure><h3 id="效果示例-5"><a href="#效果示例-5" class="headerlink" title="效果示例"></a>效果示例</h3></li></ul><ul><li>1.<ul><li>a.</li><li>b.        </li><li>c.        </li></ul></li></ul><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行-分割表头和内容</span><br><span class="line">-的个数无要求</span><br></pre></td></tr></table></figure><h2 id="效果示例-6"><a href="#效果示例-6" class="headerlink" title="效果示例"></a>效果示例</h2><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1|2|3</span><br><span class="line">---|:--:|---:</span><br><span class="line">123|234|567</span><br><span class="line">789|135|178</span><br></pre></td></tr></table></figure><table><thead><tr><th>1</th><th align="center">2</th><th align="right">3</th></tr></thead><tbody><tr><td>123</td><td align="center">234</td><td align="right">567</td></tr><tr><td>789</td><td align="center">135</td><td align="right">178</td></tr></tbody></table><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h2><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure><h3 id="效果示例-7"><a href="#效果示例-7" class="headerlink" title="效果示例"></a>效果示例</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;iostream&#96;</span><br></pre></td></tr></table></figure><p><code>iostream</code></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">代码内容</span><br><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">使用时将()去除</span><br></pre></td></tr></table></figure><h3 id="效果示例-8"><a href="#效果示例-8" class="headerlink" title="效果示例"></a>效果示例</h3><p>实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown使用反斜线()进行特殊字符转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Markdown 支持以下这些符号前面加上反斜杠(\)来帮助插入普通的符号：</span><br><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">title可有可无，如果有加空格</span><br></pre></td></tr></table></figure><h2 id="效果示例-9"><a href="#效果示例-9" class="headerlink" title="效果示例"></a>效果示例</h2><p>实例代码<br><code>![代码块](http://lc-PxV7UWpY.cn-n1.lcfile.com/88637d709890c63c45ef/iostream.png)</code><br><img src="http://lc-pxv7uwpy.cn-n1.lcfile.com/88637d709890c63c45ef/iostream.png" alt="代码块"></p><h2 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h2><p>图片的URL可以用LeanCLoud上传.不过也有更好的图床</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><p>Hexo默认不支持Markdown语法的流程图,在hexo的根目录上输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(&#96;&#96;&#96;)flow   </span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">(&#96;&#96;&#96;)    使用删()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="语法讲解"><a href="#语法讲解" class="headerlink" title="语法讲解"></a>语法讲解</h3><p>以<code>st=&gt;start</code>为例:st为变量名,start为操作模块名，冒号后面为显示的标题。标题与冒号之间有空格<br>标题后面也可以加超链接如<code>st=&gt;start: 开始:&gt;https://www.baidu.com/</code>点图标跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 跳转:&gt;https:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br><span class="line">ed&#x3D;&gt;end: 123</span><br><span class="line">st-&gt;ed</span><br></pre></td></tr></table></figure><p><strong>所有操作模块名</strong></p><table><thead><tr><th>操作模块</th><th align="center">说明</th></tr></thead><tbody><tr><td>start</td><td align="center">开始</td></tr><tr><td>end</td><td align="center">结束</td></tr><tr><td>opration</td><td align="center">普通操作块</td></tr><tr><td>condition</td><td align="center">判断块</td></tr><tr><td>subroutine</td><td align="center">子任务块</td></tr><tr><td>inputoutput</td><td align="center">输入输出块</td></tr></tbody></table><p><code>st-&gt;op-&gt;cond</code>中用变量名指向另一个变量名-&gt;≈箭头<br><code>cond(yes)-&gt;e</code> <code>cond(no)-&gt;op</code>这两个中的yes,no只能用英文。类似if判断</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;markdown支持html语言，因此如果markdown没有的语法可以使用html来代替&lt;/p&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="markdown" scheme="https://jiangyin0750.github.io/categories/markdown/"/>
    
    
    <category term="markdown" scheme="https://jiangyin0750.github.io/tags/markdown/"/>
    
    <category term="笔记" scheme="https://jiangyin0750.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jiangyin0750.github.io/post/uncategorized/hello-world/"/>
    <id>https://jiangyin0750.github.io/post/uncategorized/hello-world/</id>
    <published>2020-07-24T06:14:08.976Z</published>
    <updated>2020-12-05T12:59:10.180Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
